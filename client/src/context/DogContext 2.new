// src/context/DogContext.js
import React, { createContext, useState, useContext, useEffect, useCallback, useRef } from 'react';
import { API_URL, debugLog, debugError } from '../config';
import { apiGet, apiPost, apiPut, apiDelete } from '../utils/apiUtils';

// Create context
const DogContext = createContext();

// Cache expiration time in milliseconds (15 minutes)
const CACHE_EXPIRATION = 15 * 60 * 1000;

// Storage keys for localStorage
const STORAGE_KEYS = {
  DOGS: 'dog_breeding_app_dogs',
  LITTERS: 'dog_breeding_app_litters',
  PUPPIES: 'dog_breeding_app_puppies',
  TIMESTAMP: 'dog_breeding_app_data_timestamp'
};

// Maximum number of retries for data loading
const MAX_RETRIES = 3;

// Provider component
export const DogProvider = ({ children }) => {
  // State for dogs
  const [dogs, setDogs] = useState([]);
  const [dogsLoading, setDogsLoading] = useState(false);
  const [dogsError, setDogsError] = useState(null);
  
  // State for litters
  const [litters, setLitters] = useState([]);
  const [littersLoading, setLittersLoading] = useState(false);
  const [littersError, setLittersError] = useState(null);
  
  // State for puppies
  const [puppies, setPuppies] = useState([]);
  const [puppiesLoading, setPuppiesLoading] = useState(false);
  const [puppiesError, setPuppiesError] = useState(null);
  
  // Global loading and error states
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // Timestamp for cache validation
  const [dataTimestamp, setDataTimestamp] = useState(null);
  
  // Refs for tracking state between renders
  const initialLoadRef = useRef(false);
  const retryAttempts = useRef(0);
  const pendingRequests = useRef({
    dogs: null,
    litters: null,
    puppies: null
  });
  
  // Function to save data to localStorage
  const saveToLocalStorage = () => {
    try {
      // Save timestamp
      if (dataTimestamp) {
        localStorage.setItem(STORAGE_KEYS.TIMESTAMP, dataTimestamp.toString());
      }
      
      // Save dogs
      if (dogs.length) {
        localStorage.setItem(STORAGE_KEYS.DOGS, JSON.stringify(dogs));
      }
      
      // Save litters
      if (litters.length) {
        localStorage.setItem(STORAGE_KEYS.LITTERS, JSON.stringify(litters));
      }
      
      // Save puppies
      if (puppies.length) {
        localStorage.setItem(STORAGE_KEYS.PUPPIES, JSON.stringify(puppies));
      }
      
      console.log('Saved data to localStorage cache');
    } catch (e) {
      console.error('Error saving to localStorage:', e);
    }
  };

  // Function to check if cache is valid
  const isCacheValid = () => {
    if (!dataTimestamp) return false;
    return (Date.now() - dataTimestamp) < CACHE_EXPIRATION;
  };

  // Define refreshData function first before using it
  const refreshData = useCallback(async (forceRefresh = false, options = {}) => {
    // Default options
    const { includeLitters = false } = options;
    
    // If already loading, don't start another request
    if (loading && !forceRefresh) {
      debugLog('Already loading data, skipping refresh');
      return;
    }
    
    setLoading(true);
    setError(null);
    
    // Fetch data with more robust error handling
    try {
      // Create promises but don't await them yet - specify exact endpoints without trailing slashes
      pendingRequests.current.dogs = apiGet('dogs');
      
      // Only fetch litters if specifically requested
      if (includeLitters) {
        debugLog('Including litters in data refresh');
        pendingRequests.current.litters = apiGet('litters');
      } else {
        debugLog('Skipping litters in data refresh');
      }
      
      // Handle dogs
      let dogsData = [];
      try {
        const dogsResponse = await pendingRequests.current.dogs;
        if (dogsResponse && dogsResponse.ok) {
          dogsData = dogsResponse.data || [];
          setDogs(dogsData);
          debugLog('Successfully loaded dogs:', dogsData.length);
        } else {
          debugError('Failed to load dogs:', dogsResponse?.error || 'Unknown error');
        }
      } catch (err) {
        debugError('Error fetching dogs:', err);
      }
      
      // Handle litters - only if requested
      if (includeLitters && pendingRequests.current.litters) {
        try {
          const littersResponse = await pendingRequests.current.litters;
          if (littersResponse && littersResponse.ok) {
            // FIXED: Ensure we're properly setting the litters data
            const littersData = littersResponse.data || [];
            debugLog('Received litters data:', littersData);
            setLitters(littersData);
          } else {
            debugError('Failed to load litters:', littersResponse?.error || 'Unknown error');
            // If litters fail, just set empty array and continue
            setLitters([]);
          }
        } catch (err) {
          debugError('Error fetching litters:', err);
          setLitters([]);
        }
      }

      // If we got here, consider the data load complete even if some requests failed
      // This prevents infinite retries when some endpoints aren't available
      initialLoadRef.current = true;
      const timestamp = Date.now();
      setDataTimestamp(timestamp);
      
      // Save data to localStorage for persistent caching
      saveToLocalStorage();
      
      // Reset retry counter on any successful load
      if (dogsData.length > 0) {
        retryAttempts.current = 0;
      }
    } catch (err) {
      debugError('Global error in refreshData:', err);
      setError('Failed to load data. Please try again.');
    } finally {
      // Clear loading state and pending requests regardless of success/failure
      setLoading(false);
      pendingRequests.current = {
        dogs: null,
        litters: null,
        puppies: null
      };
    }
  }, [loading]);

  // Add specific refresh functions for different data types
  const refreshDogs = useCallback((forceRefresh = false, options = {}) => {
    debugLog('Refreshing dogs with options:', options);
    return refreshData(forceRefresh, options);
  }, [refreshData]);
  
  // FIXED: Improved refreshLitters function to ensure it always includes litters
  const refreshLitters = useCallback((forceRefresh = false) => {
    debugLog('Refreshing litters with forceRefresh:', forceRefresh);
    // Always include litters in the refresh
    return refreshData(forceRefresh, { includeLitters: true });
  }, [refreshData]);

  // Load data from localStorage on initial mount
  useEffect(() => {
    const loadFromLocalStorage = () => {
      try {
        // Check if we have a timestamp
        const timestampStr = localStorage.getItem(STORAGE_KEYS.TIMESTAMP);
        if (!timestampStr) {
          console.log('No cached data timestamp found');
          return false;
        }
        
        const timestamp = parseInt(timestampStr, 10);
        if (isNaN(timestamp)) {
          console.log('Invalid timestamp in cache');
          return false;
        }
        
        // Check if cache is still valid (within expiration window)
        if ((Date.now() - timestamp) < CACHE_EXPIRATION) {
          console.log('Loading data from localStorage cache');
          
          // Set the timestamp in component state
          setDataTimestamp(timestamp);
          
          // Load dogs
          const cachedDogs = localStorage.getItem(STORAGE_KEYS.DOGS);
          if (cachedDogs) {
            try {
              const parsedDogs = JSON.parse(cachedDogs);
              if (Array.isArray(parsedDogs)) {
                setDogs(parsedDogs);
                console.log(`Loaded ${parsedDogs.length} dogs from cache`);
              }
            } catch (e) {
              console.error('Error parsing cached dogs:', e);
            }
          }
          
          // Load litters
          const cachedLitters = localStorage.getItem(STORAGE_KEYS.LITTERS);
          if (cachedLitters) {
            try {
              const parsedLitters = JSON.parse(cachedLitters);
              if (Array.isArray(parsedLitters)) {
                setLitters(parsedLitters);
                console.log(`Loaded ${parsedLitters.length} litters from cache`);
              }
            } catch (e) {
              console.error('Error parsing cached litters:', e);
            }
          }
          
          // Load puppies
          const cachedPuppies = localStorage.getItem(STORAGE_KEYS.PUPPIES);
          if (cachedPuppies) {
            try {
              const parsedPuppies = JSON.parse(cachedPuppies);
              if (Array.isArray(parsedPuppies)) {
                setPuppies(parsedPuppies);
                console.log(`Loaded ${parsedPuppies.length} puppies from cache`);
              }
            } catch (e) {
              console.error('Error parsing cached puppies:', e);
            }
          }
          
          // Mark initial load as complete
          initialLoadRef.current = true;
        } else {
          console.log('Cache expired, will fetch fresh data');
          return false;
        }
        
        return true;
      } catch (e) {
        console.error('Error loading from localStorage:', e);
        return false;
      }
    };
    
    // Try to load from cache, if that fails, fetch fresh data
    if (!loadFromLocalStorage()) {
      refreshData(true);
    }
  }, [refreshData]);

  // Update the useEffect to only fetch data on mount, not on every render
  useEffect(() => {
    // Only fetch if we don't already have data
    if (dogs.length === 0 && !dogsLoading) {
      refreshDogs();
    }
  }, [refreshDogs, dogs.length, dogsLoading]);

  // Add dog
  const addDog = async (dogData) => {
    try {
      const response = await apiPost('dogs', dogData);
      if (response && response.ok) {
        // Add new dog to state
        setDogs(prevDogs => [...prevDogs, response.data]);
        return { success: true, data: response.data };
      } else {
        throw new Error(response?.error || 'Failed to add dog');
      }
    } catch (error) {
      debugError('Error adding dog:', error);
      return { success: false, error: error.message };
    }
  };

  // Update dog
  const updateDog = async (dogId, dogData) => {
    try {
      const response = await apiPut(`dogs/${dogId}`, dogData);
      if (response && response.ok) {
        // Update dog in state
        setDogs(prevDogs => 
          prevDogs.map(dog => 
            dog.id === dogId ? { ...dog, ...response.data } : dog
          )
        );
        return { success: true, data: response.data };
      } else {
        throw new Error(response?.error || 'Failed to update dog');
      }
    } catch (error) {
      debugError('Error updating dog:', error);
      return { success: false, error: error.message };
    }
  };

  // Delete dog
  const deleteDog = async (dogId) => {
    try {
      const response = await apiDelete(`dogs/${dogId}`);
      if (response && response.ok) {
        // Remove dog from state
        setDogs(prevDogs => prevDogs.filter(dog => dog.id !== dogId));
        return { success: true };
      } else {
        throw new Error(response?.error || 'Failed to delete dog');
      }
    } catch (error) {
      debugError('Error deleting dog:', error);
      return { success: false, error: error.message };
    }
  };

  // Add litter
  const addLitter = async (litterData) => {
    try {
      const response = await apiPost('litters', litterData);
      if (response && response.ok) {
        // Add new litter to state
        setLitters(prevLitters => [...prevLitters, response.data]);
        return { success: true, data: response.data };
      } else {
        throw new Error(response?.error || 'Failed to add litter');
      }
    } catch (error) {
      debugError('Error adding litter:', error);
      return { success: false, error: error.message };
    }
  };

  // Update litter
  const updateLitter = async (litterId, litterData) => {
    try {
      const response = await apiPut(`litters/${litterId}`, litterData);
      if (response && response.ok) {
        // Update litter in state
        setLitters(prevLitters => 
          prevLitters.map(litter => 
            litter.id === litterId ? { ...litter, ...response.data } : litter
          )
        );
        return { success: true, data: response.data };
      } else {
        throw new Error(response?.error || 'Failed to update litter');
      }
    } catch (error) {
      debugError('Error updating litter:', error);
      return { success: false, error: error.message };
    }
  };

  // Delete litter
  const deleteLitter = (litterId) => {
    setLitters(prev => prev.filter(litter => litter.id !== litterId));
  };

  // Provide context value
  const contextValue = {
    // Dogs
    dogs,
    dogsLoading,
    dogsError,
    addDog,
    updateDog,
    deleteDog,
    refreshDogs,
    
    // Litters
    litters,
    littersLoading,
    littersError,
    addLitter,
    updateLitter,
    deleteLitter,
    refreshLitters,
    
    // Puppies
    puppies,
    puppiesLoading,
    puppiesError,
    
    // Global state
    loading,
    error,
    
    // Cache info
    dataTimestamp,
    isCacheValid
  };

  return (
    <DogContext.Provider value={contextValue}>
      {children}
    </DogContext.Provider>
  );
};

// Custom hook for using the context
export const useDog = () => {
  const context = useContext(DogContext);
  if (!context) {
    throw new Error('useDog must be used within a DogProvider');
  }
  return context;
};

export default DogContext;
